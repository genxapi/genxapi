#!/usr/bin/env node
import { buildApplication, buildCommand, type CommandContext, run } from "@stricli/core";
import { createRequire } from "module";
import { resolve as resolvePath } from "node:path";
import { loadGeneratorConfig } from "./lib/config.js";
import { runGenerator } from "./lib/generator.js";
import { Logger } from "./lib/logger.js";

const require = createRequire(import.meta.url);
const pkg = require("../package.json") as { version?: string; description?: string };

interface CliContext extends CommandContext {
  readonly process: NodeJS.Process;
  readonly logger: Logger;
}

interface GenerateFlags {
  readonly config?: string;
  readonly template?: string;
  readonly target?: string;
  readonly projectName?: string;
  readonly swagger?: string;
  readonly swaggerTarget?: string;
  readonly packageManager?: string;
  readonly skipInstall: boolean;
  readonly skipGenerate: boolean;
  readonly skipCopySwagger: boolean;
  readonly dryRun: boolean;
  readonly force: boolean;
  readonly logLevel?: string;
  readonly baseUrl?: string;
  readonly workspace?: string;
  readonly targetFile?: string;
  readonly orvalConfig?: string;
  readonly orvalCommand?: string;
  readonly postGenerate?: string;
  readonly templateVar?: readonly string[];
}

type GeneratePositional = [];

const command = buildCommand<GenerateFlags, GeneratePositional, CliContext>({
  func: async function (flags) {
    const logger = this.logger;
    logger.setLevel(flags.logLevel);

    try {
      const overrides = buildOverrides(flags);
      const config = await loadGeneratorConfig({
        configPath: flags.config,
        workingDirectory: this.process.cwd(),
        logger,
        overrides,
      });

      if (flags.dryRun) {
        logger.success("Configuration validated successfully (dry run).");
        return;
      }

      await runGenerator(config, { logger });
    } catch (error) {
      logger.error(
        error instanceof Error ? error.message : "Unexpected error running generator"
      );
      if (logger.isDebugEnabled() && error instanceof Error && error.stack) {
        logger.debug(error.stack);
      }
      this.process.exitCode = 1;
      return;
    }
  },
  parameters: {
    positional: {
      kind: "tuple",
      parameters: [],
    },
    flags: {
      config: {
        kind: "parsed",
        brief: "Path to configuration file",
        parse: String,
        optional: true,
      },
      template: {
        kind: "parsed",
        brief: "Name of the project template to scaffold (default: client-api)",
        parse: String,
        optional: true,
      },
      target: {
        kind: "parsed",
        brief: "Output directory for the generated client project",
        parse: String,
        optional: true,
      },
      projectName: {
        kind: "parsed",
        brief: "Package name for the generated client",
        parse: String,
        optional: true,
      },
      swagger: {
        kind: "parsed",
        brief: "Path or URL to the OpenAPI document",
        parse: String,
        optional: true,
      },
      swaggerTarget: {
        kind: "parsed",
        brief: "Destination filename for the copied OpenAPI document within the project",
        parse: String,
        optional: true,
      },
      packageManager: {
        kind: "parsed",
        brief: "Package manager to use (npm|pnpm|yarn|bun, default: npm)",
        parse: parsePackageManager,
        optional: true,
      },
      skipInstall: {
        kind: "boolean",
        brief: "Skip installing template dependencies",
        default: false,
      },
      skipGenerate: {
        kind: "boolean",
        brief: "Skip executing the orval generate command",
        default: false,
      },
      skipCopySwagger: {
        kind: "boolean",
        brief: "Do not copy the OpenAPI document into the project",
        default: false,
      },
      dryRun: {
        kind: "boolean",
        brief: "Validate configuration and exit without making changes",
        default: false,
      },
      force: {
        kind: "boolean",
        brief: "Overwrite existing files in the target directory",
        default: false,
      },
      logLevel: {
        kind: "parsed",
        brief: "Log level (silent|error|warn|info|debug)",
        parse: String,
        optional: true,
      },
      baseUrl: {
        kind: "parsed",
        brief: "Override the baseUrl value in the orval configuration",
        parse: String,
        optional: true,
      },
      workspace: {
        kind: "parsed",
        brief: "Override the workspace path used by orval",
        parse: String,
        optional: true,
      },
      targetFile: {
        kind: "parsed",
        brief: "Override the target file path generated by orval",
        parse: String,
        optional: true,
      },
      orvalConfig: {
        kind: "parsed",
        brief: "Override the orval configuration filename",
        parse: String,
        optional: true,
      },
      orvalCommand: {
        kind: "parsed",
        brief: "Script name to run for orval generation",
        parse: String,
        optional: true,
      },
      postGenerate: {
        kind: "parsed",
        brief: "Script name to run after the orval command completes",
        parse: String,
        optional: true,
      },
      templateVar: {
        kind: "parsed",
        brief: "Set additional template variable (KEY=VALUE)",
        parse: String,
        variadic: true,
        optional: true,
      },
    },
  },
  docs: {
    brief: pkg.description ?? "Generate an API client project from a template",
  },
});

const app = buildApplication(command, {
  name: "generate-api-client",
  versionInfo: {
    currentVersion: pkg.version ?? "0.0.0",
  },
});

run(app, process.argv.slice(2), buildContext(process)).catch((error) => {
  if (error instanceof Error) {
    console.error(error.stack ?? error.message);
  } else if (error) {
    console.error(error);
  }
  if (!process.exitCode) {
    process.exitCode = 1;
  }
});

function buildContext(proc: NodeJS.Process): CliContext {
  return {
    process: proc,
    logger: new Logger(),
  };
}

function parsePackageManager(input: string): string {
  const normalized = input.toLowerCase();
  if (!["npm", "pnpm", "yarn", "bun"].includes(normalized)) {
    throw new Error(`Unsupported package manager "${input}". Expected npm, pnpm, yarn, or bun.`);
  }
  return normalized;
}

function buildOverrides(flags: GenerateFlags) {
  const overrides: Record<string, unknown> = {};

  if (flags.template) {
    overrides.template = flags.template;
  }
  if (flags.packageManager) {
    overrides.packageManager = flags.packageManager;
  }

  if (flags.target) {
    overrides.targetDirectory = resolvePath(flags.target);
  }
  if (flags.projectName) {
    overrides.projectName = flags.projectName;
  }
  if (flags.swagger) {
    overrides.swaggerPath = flags.swagger;
  }
  if (flags.swaggerTarget) {
    overrides.swaggerCopyTarget = flags.swaggerTarget;
  }
  if (flags.skipInstall) {
    overrides.installDependencies = false;
  }
  if (flags.skipGenerate) {
    overrides.runGenerate = false;
  }
  if (flags.skipCopySwagger) {
    overrides.copySwagger = false;
  }
  if (flags.force) {
    overrides.force = true;
  }

  const orvalOverrides: Record<string, unknown> = {};
  if (flags.baseUrl) {
    orvalOverrides.baseUrl = flags.baseUrl;
  }
  if (flags.workspace) {
    orvalOverrides.workspace = flags.workspace;
  }
  if (flags.targetFile) {
    orvalOverrides.targetFile = flags.targetFile;
  }
  if (flags.orvalConfig) {
    orvalOverrides.configPath = flags.orvalConfig;
  }
  if (flags.orvalCommand) {
    orvalOverrides.command = flags.orvalCommand;
  }
  if (flags.postGenerate) {
    orvalOverrides.postGenerateScript = flags.postGenerate;
  }
  if (Object.keys(orvalOverrides).length > 0) {
    overrides.orval = orvalOverrides;
  }

  const templateVariables = parseTemplateVariables(flags.templateVar);
  if (Object.keys(templateVariables).length > 0) {
    overrides.templateVariables = templateVariables;
  }

  return overrides;
}

function parseTemplateVariables(values: readonly string[] | undefined): Record<string, string> {
  if (!values || values.length === 0) {
    return {};
  }

  return values.reduce<Record<string, string>>((acc, entry) => {
    const index = entry.indexOf("=");
    if (index <= 0) {
      throw new Error(
        `Invalid template variable "${entry}". Expected the format KEY=VALUE.`
      );
    }
    const key = entry.slice(0, index).trim();
    const value = entry.slice(index + 1);
    if (!key) {
      throw new Error(`Invalid template variable "${entry}". Key cannot be empty.`);
    }
    acc[key.toUpperCase()] = value;
    return acc;
  }, {});
}

